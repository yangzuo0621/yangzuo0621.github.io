---
title: 虚拟机类加载机制
date: 2017-07-29 16:50:52
categories:
- Java
tags:
- 学习笔记
---

### 类的生命周期

> 虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。

在Java世界中，类及其实例（或对象）在使用之前，必须通过`类加载器`将描述类的详细信息载入内存中。类从载入内容到卸载，一般会经历如下的过程，加载、验证、准备、解析、初始化、使用和卸载。

#### 加载

这一阶段主要完成三件事：

1. 通过一个类的全限定名获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的`java.lang.Class`对象，作为方法区这个类的各种数据的访问入口。

二进制字节流的获取并没要求一定是从Class文件中来，只要是符合虚拟机规范的都可以，如zip包、网络、数据库、其他文件生成等。

数组类本身不通过类加载器创建，它由Java虚拟机直接创建。

#### 验证

这一阶段主要是对Class文件的字节流中的信息是否符合当前虚拟机的要求做验证，避免产生危害虚拟机自身安全行为的发生。包括：

+ 文件格式验证
+ 元数据验证
+ 字节码验证
+ 符号引用验证

#### 准备

这一阶段在方法区内，为类变量分配内存并设置类变量类型的初始值。

#### 解析

这一阶段虚拟机将常量池内的符号引用替换为直接引用的过程。包括：

+ 类或接口的解析
+ 字段解析
+ 类方法解析
+ 接口方法解析

#### 初始化

初始化阶段是执行类构造器`<clinit>()`方法的过程。

如果类没有进行初始化，以下5中情况会立即进行类的“初始化”：

1. 当遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，会触发类的初始化过程。对应到语言层面就是，使用new关键字实例化对象、读取或设置类的静态字段，以及调用类的静态方法。
2. 使用java.lang.reflect包的方法对类进行反射调用。
3. 当初始化一个类的时候，其父类还没有进行初始化，则需要触发其父类的初始化。
4. 虚拟机启动时，初始化用户指定的主类(包含main方法)。
5. JDK1.7以上，使用动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄。

例子：以下情形不会触发初始化
1. 通过子类引用父类的静态字段，不会触发子类初始化，只会触发父类的初始化
2. 通过数组定义来引用类，不会触发类的初始化，
3. 常量在编译阶段会存入调用类的常量池中，调用类的常量不会触发类的初始化。

### 类与类加载器

对于任意一个类，都需要由加载它的类加载器和类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间，意味着，同一个类即使它来自同一个Class文件，只要被不同的类加载器加载，这两个类就不相等。

#### 分类
在Java虚拟机中，有如下3中类加载器。

1. 启动类加载器（Bootstrap ClassLoader），负责加载`$JAVA_HOME\lib`目录中，或被`-Xbootclasspath`参数指定的路径中，并被虚拟机识别的类。
2. 扩展类加载器（Extension ClassLoader），复杂加载`$JAVA_HOME\lib\ext`目录或被`java.ext.dirs`指定路径中的类库。
3. 应用程序类加载器（Application ClassLoader），由`sun.misc.Launcher$AppClassLoader`实现。它是ClassLoader类中getSystemClassLoader()方法的返回值，复杂加载用户类（classpath）上指定的类库。程序默认的类加载器。
4. 自定义类加载器。

#### 双亲委派模型

双亲委派模型是虚拟机中类加载器的组织方式。

工作过程：
如果一个类加载器收到了类加载的请求，首先它不会自己去尝试加载这个类，而是把这个类的请求委托给其父类加载器加载，只有当父类加载器反馈无法完成这个加载请求时，子加载器才会去尝试加载。这样使得Java类随着它的类加载器一起具备了一种优先级的层次关系，保证了类的唯一性。

PS：欢迎批评指正。
> 参考：深入理解Java虚拟机 —— 虚拟机类加载机制 第7章